<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Carioca</title>
  <link rel="manifest" href="./manifest.webmanifest">
  <link rel="apple-touch-icon" href="./icons/icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="theme-color" content="#111827" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>html,body,#root{height:100%;}</style>
</head>
<body class="bg-slate-100 text-slate-900">
  <div id="root"></div>
  <script type="text/babel">
    const { useEffect, useMemo, useState } = React;

    const APP_VERSION = "v0.5";

    const NS = "carioca-game-v2";
    const GAMES_KEY = NS + ":games";
    const GAME_PREFIX = NS + ":game:";
    const LAST_GAME_KEY = NS + ":last";
    const uid = () => Math.random().toString(36).slice(2, 10);

    const SUITS = ["‚ô†","‚ô•","‚ô¶","‚ô£"];
    const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
    const RED_SUITS = new Set(["‚ô•","‚ô¶"]);
    const BLACK_SUITS = new Set(["‚ô†","‚ô£"]);
    const SUIT_ORDER = ["‚ô†", "‚ô•", "‚ô¶", "‚ô£"];

    const AI_LEVELS = ["Easy", "Medium", "Hard"];
    const ROUND_DEFS = [
      { name: "Two three-of-a-kind", components: ["set3","set3"] },
      { name: "One straight + one three-of-a-kind", components: ["straight4","set3"] },
      { name: "Two straights", components: ["straight4","straight4"] },
      { name: "Three three-of-a-kind", components: ["set3","set3","set3"] },
      { name: "Two three-of-a-kind + one straight", components: ["set3","set3","straight4"] },
      { name: "Two straights + one three-of-a-kind", components: ["straight4","straight4","set3"] },
      { name: "Four three-of-a-kind", components: ["set3","set3","set3","set3"] },
      { name: "Three straights", components: ["straight4","straight4","straight4"] },
      { name: "Crazy straight", components: ["crazy13"] },
      { name: "Colour straight", components: ["color13"] },
      { name: "Royal straight", components: ["royal13"] },
    ];

    const CARD_POINTS = { A:20, J:10, Q:10, K:10, JOKER:30 };

    const ADJ = ["Bruno","Rafa","Mateo","Nico","Julia","Ines","Sofia","Luca","Dario","Tiago","Carla","Maya"];
    const LAST = ["Silva","Costa","Pereira","Ramos","Lima","Cardoso","Mendes","Oliveira","Santos","Rocha","Almeida","Nunes"];

    const ls = {
      read(k, fb){ try{ const v = localStorage.getItem(k); return v ? JSON.parse(v) : fb; } catch { return fb; } },
      write(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); } catch {} }
    };

    function randomComputerName(){
      return `${ADJ[Math.floor(Math.random()*ADJ.length)]} ${LAST[Math.floor(Math.random()*LAST.length)]}`;
    }

    function cardLabel(c){ return c.joker ? "üÉè" : `${c.rank}${c.suit}`; }
    function cardColorClass(c){
      if(c.joker || !c.suit) return "text-slate-900";
      return RED_SUITS.has(c.suit) ? "text-red-600" : "text-slate-900";
    }
    function cardColorWhenActive(c, active){
      if(active) return "text-white";
      return cardColorClass(c);
    }
    function formatMeldLabel(meld, index){
      const cardsPreview = meld.cards.map(cardLabel).join(" ");
      return `${meld.owner} - ${componentDesc(meld.type)} #${index+1}: ${cardsPreview}`;
    }
    function cardPoint(c){ return c.joker ? 30 : (CARD_POINTS[c.rank] ?? Number(c.rank)); }

    function newDeck(){
      const deck = [];
      for(let d=0; d<2; d++){
        for(const s of SUITS){
          for(const r of RANKS){ deck.push({ id: uid(), rank:r, suit:s, joker:false }); }
        }
        deck.push({ id: uid(), rank:"JOKER", suit:null, joker:true });
        deck.push({ id: uid(), rank:"JOKER", suit:null, joker:true });
      }
      return shuffle(deck);
    }

    function shuffle(arr){
      const out = [...arr];
      for(let i=out.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [out[i], out[j]] = [out[j], out[i]];
      }
      return out;
    }

    function dealRound(){
      const deck = newDeck();
      const hands = { human: [], computer: [] };
      for(let i=0;i<12;i++){
        hands.human.push(deck.pop());
        hands.computer.push(deck.pop());
      }
      const discard = [deck.pop()];
      return { deck, discard, hands };
    }

    function componentDesc(c){
      return ({ set3:"Set of 3", straight4:"Straight of 4", crazy13:"Crazy straight (13)", color13:"Colour straight (13)", royal13:"Royal straight (13)" })[c];
    }

    function rankNum(rank, aceHigh=false){
      if(rank === "A") return aceHigh ? 14 : 1;
      if(rank === "J") return 11;
      if(rank === "Q") return 12;
      if(rank === "K") return 13;
      return Number(rank);
    }

    function canFormSet(cards){
      if(cards.length !== 3) return false;
      const naturals = cards.filter(c=>!c.joker);
      if(!naturals.length) return true;
      return naturals.every(c => c.rank === naturals[0].rank);
    }

    function sequenceRank(start, offset){
      return ((start - 1 + offset) % 13) + 1;
    }

    function rankForCard(card){
      return rankNum(card.rank, false);
    }

    function getStraightSuitMode(kind){
      if(kind === "crazy13") return "any";
      if(kind === "color13") return "color";
      return "suit";
    }

    function naturalsMatchSuitMode(cards, mode){
      const naturals = cards.filter(c=>!c.joker);
      if(!naturals.length) return true;
      if(mode === "any") return true;
      if(mode === "color"){
        const color = RED_SUITS.has(naturals[0].suit) ? "red" : "black";
        return naturals.every(c => (RED_SUITS.has(c.suit) ? "red" : "black") === color);
      }
      return naturals.every(c=>c.suit === naturals[0].suit);
    }

    function findUnorderedStraightAssignment(cards, len, mode="suit"){
      if(cards.length !== len || len < 3 || len > 13) return null;
      if(!naturalsMatchSuitMode(cards, mode)) return null;
      const naturals = cards.filter(c=>!c.joker);
      const jokers = cards.filter(c=>c.joker);
      const naturalByRank = new Map();
      for(const c of naturals){
        const r = rankForCard(c);
        const list = naturalByRank.get(r) || [];
        list.push(c);
        naturalByRank.set(r, list);
      }
      for(const cardsAtRank of naturalByRank.values()) if(cardsAtRank.length > 1) return null;

      for(let start=1; start<=13; start++){
        const slots = Array(len).fill(null);
        let ok = true;
        for(let i=0;i<len;i++){
          const r = sequenceRank(start, i);
          const list = naturalByRank.get(r);
          if(list?.length) slots[i] = list[0];
        }
        const missing = slots.filter(x=>!x).length;
        if(missing !== jokers.length){ ok = false; }
        if(!ok) continue;
        let ji = 0;
        for(let i=0;i<len;i++) if(!slots[i]) slots[i] = jokers[ji++];
        return { start, slots };
      }
      return null;
    }

    function resolveOrderedStraight(cards, mode="suit"){
      const len = cards.length;
      if(len < 3 || len > 13) return null;
      if(!naturalsMatchSuitMode(cards, mode)) return null;
      for(let start=1; start<=13; start++){
        let ok = true;
        const ranks = [];
        for(let i=0;i<len;i++){
          const expected = sequenceRank(start, i);
          ranks.push(expected);
          const card = cards[i];
          if(!card.joker && rankForCard(card) !== expected){ ok = false; break; }
        }
        if(ok) return { start, ranks };
      }
      return null;
    }

    function normalizeStraightCards(cards, kind){
      const assignment = findUnorderedStraightAssignment(cards, cards.length, getStraightSuitMode(kind));
      return assignment ? assignment.slots : null;
    }

    function validateStraight(cards, kind){
      const len = kind === "straight4" ? 4 : 13;
      return !!findUnorderedStraightAssignment(cards, len, getStraightSuitMode(kind));
    }

    function canExtendStraightOnSide(meldCards, addedCards, side, kind){
      if(!addedCards.length) return null;
      const mode = getStraightSuitMode(kind);
      let base = meldCards;
      let baseState = resolveOrderedStraight(base, mode);
      if(!baseState){
        base = normalizeStraightCards(meldCards, kind) || meldCards;
        baseState = resolveOrderedStraight(base, mode);
      }
      if(!baseState) return null;

      const candidate = side === "left" ? [...addedCards, ...base] : [...base, ...addedCards];
      if(candidate.length > 13) return null;
      const candidateState = resolveOrderedStraight(candidate, mode);
      if(!candidateState) return null;

      const offset = side === "left" ? addedCards.length : 0;
      for(let i=0;i<baseState.ranks.length;i++){
        if(candidateState.ranks[offset+i] !== baseState.ranks[i]) return null;
      }
      return candidate;
    }

    function validateMeld(cards, type){
      if(type === "set3") return canFormSet(cards);
      return validateStraight(cards, type);
    }

    function objectiveDone(playerMelds, components){
      return playerMelds.length >= components.length;
    }

    function groupByRank(cards){
      const m = new Map();
      cards.forEach(c=>{ if(c.joker) return; const a = m.get(c.rank)||[]; a.push(c); m.set(c.rank,a); });
      return m;
    }

    function findObjectiveMelds(hand, components, level){
      const idxMap = new Map(hand.map((c,i)=>[c.id,i]));
      const result = [];
      let remaining = [...hand];
      const order = level === "Hard" ? components : shuffle(components);
      for(const comp of order){
        let found = null;
        const combos = combinations(remaining, comp === "set3" ? 3 : (comp === "straight4" ? 4 : 13));
        for(const cards of combos){
          if(validateMeld(cards, comp)) { found = cards; break; }
        }
        if(!found) return [];
        result.push({ type: comp, cards: found });
        const ids = new Set(found.map(c=>c.id));
        remaining = remaining.filter(c=>!ids.has(c.id));
      }
      return result;
    }

    function combinations(arr, k){
      const out = [];
      const n = arr.length;
      function rec(start, path){
        if(path.length===k){ out.push([...path]); return; }
        for(let i=start;i<n;i++){
          path.push(arr[i]); rec(i+1,path); path.pop();
        }
      }
      if(k<=arr.length) rec(0,[]);
      return out;
    }

    function applyLayoffToMeld(meld, cards){
      if(!cards.length) return null;
      if(meld.type === "set3"){
        const merged = [...meld.cards, ...cards];
        const naturals = merged.filter(c=>!c.joker);
        return naturals.length === 0 || naturals.every(c=>c.rank === naturals[0].rank) ? merged : null;
      }
      return canExtendStraightOnSide(meld.cards, cards, "right", meld.type) || canExtendStraightOnSide(meld.cards, cards, "left", meld.type);
    }

    function canLayoffToMeld(meld, cards){
      return !!applyLayoffToMeld(meld, cards);
    }

    function newGameState(humanName, aiLevel){
      const { deck, discard, hands } = dealRound();
      return {
        humanName,
        computerName: randomComputerName(),
        aiLevel,
        handSortMode: "rank",
        turnAddedCardIds: [],
        phase: "playing",
        roundIndex: 0,
        currentPlayer: "human",
        hasDrawn: false,
        round: {
          deck,
          discard,
          hands,
          tableMelds: [],
          laid: { human: [], computer: [] },
          winner: null,
        },
        totals: { human: 0, computer: 0 },
        history: [],
        message: "Game started.",
      };
    }

    function App(){
      const [games, setGames] = useState(()=>ls.read(GAMES_KEY, []));
      const [gameId, setGameId] = useState(()=>ls.read(LAST_GAME_KEY, null));
      const [state, setState] = useState(null);
      const [selected, setSelected] = useState([]);
      const [meldTarget, setMeldTarget] = useState("");

      useEffect(()=>{
        if(!games.length){
          const id = uid();
          const meta = { id, name: "Game 1", updatedAt: Date.now() };
          const s = newGameState("Player", "Medium");
          ls.write(GAME_PREFIX+id, s);
          ls.write(GAMES_KEY, [meta]);
          ls.write(LAST_GAME_KEY, id);
          setGames([meta]); setGameId(id); setState(s);
          return;
        }
        const id = gameId || games[0].id;
        const saved = ls.read(GAME_PREFIX+id, null);
        if(saved){ setGameId(id); setState(saved); }
      },[]);

      useEffect(()=>{
        if(!state || !gameId) return;
        ls.write(GAME_PREFIX+gameId, state);
        ls.write(LAST_GAME_KEY, gameId);
        const next = games.map(g=>g.id===gameId?{...g, updatedAt:Date.now()}:g);
        setGames(next);
        ls.write(GAMES_KEY, next);
      },[state]);

      useEffect(()=>{
        if(!state || state.phase !== "playing" || state.currentPlayer !== "computer") return;
        const t = setTimeout(()=>setState(prev=>runAiTurn(prev)), 700);
        return ()=>clearTimeout(t);
      },[state]);

      useEffect(()=>{
        if(!state || state.handSortMode) return;
        setState(prev => prev ? { ...prev, handSortMode: "rank" } : prev);
      }, [state]);

      const roundDef = state ? ROUND_DEFS[state.roundIndex] : null;
      const humanHand = state?.round.hands.human || [];
      const computerHandCount = state?.round.hands.computer?.length || 0;
      const humanObjectiveComplete = state ? objectiveDone(state.round.laid.human, roundDef.components) : false;

      function createGame(){
        const humanName = prompt("Your name?", "Player") || "Player";
        const aiLevel = prompt("AI level: Easy / Medium / Hard", "Medium") || "Medium";
        const level = AI_LEVELS.includes(aiLevel) ? aiLevel : "Medium";
        const id = uid();
        const name = `${humanName} vs AI`;
        const meta = { id, name, updatedAt: Date.now() };
        const s = newGameState(humanName, level);
        const next = [...games, meta];
        setGames(next); ls.write(GAMES_KEY, next);
        setGameId(id); setState(s);
        ls.write(GAME_PREFIX+id, s); ls.write(LAST_GAME_KEY, id);
      }

      function switchGame(id){
        const s = ls.read(GAME_PREFIX+id, null);
        if(s){ setGameId(id); setState(s); setSelected([]); }
      }

      function draw(from){
        setState(prev=>{
          if(!prev || prev.phase !== "playing" || prev.currentPlayer !== "human" || prev.hasDrawn) return prev;
          const src = from === "discard" ? prev.round.discard : prev.round.deck;
          if(!src.length) return { ...prev, message: "No cards available there." };
          const card = src[src.length-1];
          const next = structuredClone(prev);
          if(from === "discard") next.round.discard.pop(); else next.round.deck.pop();
          next.round.hands.human.push(card);
          next.hasDrawn = true;
          next.turnAddedCardIds = [];
          next.message = `You drew ${cardLabel(card)} from ${from}.`;
          return next;
        });
      }

      function toggleSelect(id){
        setSelected(prev => prev.includes(id) ? prev.filter(x=>x!==id) : [...prev, id]);
      }

      function setHandSortMode(mode){
        setState(prev => {
          if(!prev) return prev;
          if(mode !== "rank" && mode !== "suit") return prev;
          return { ...prev, handSortMode: mode };
        });
      }

      function selectedCards(hand){
        const m = new Set(selected);
        return hand.filter(c=>m.has(c.id));
      }

      function layObjective(){
        setState(prev=>{
          if(!prev || prev.phase!=="playing" || prev.currentPlayer!=="human" || !prev.hasDrawn) return prev;
          const cards = selectedCards(prev.round.hands.human);
          const done = prev.round.laid.human;
          if(done.length >= roundDef.components.length) return { ...prev, message: "Objective already complete. You can only add cards to table melds now." };
          const comp = findMatchingComponent(roundDef.components, done, cards);
          if(!comp) return { ...prev, message: "Selected cards do not match an unmet objective meld." };
          const next = structuredClone(prev);
          const meldCards = comp === "set3" ? cards : normalizeStraightCards(cards, comp);
          next.round.tableMelds.push({ id: uid(), owner: "human", type: comp, cards: meldCards || cards });
          next.turnAddedCardIds = [...(next.turnAddedCardIds || []), ...cards.map(c=>c.id)];
          next.round.laid.human.push(comp);
          const ids = new Set(cards.map(c=>c.id));
          next.round.hands.human = next.round.hands.human.filter(c=>!ids.has(c.id));
          next.message = `You laid ${componentDesc(comp)}.`;
          setSelected([]);
          return maybeFinishRound(next, "human");
        });
      }

      function addToMeld(){
        setState(prev=>{
          if(!prev || prev.phase!=="playing" || prev.currentPlayer!=="human" || !prev.hasDrawn) return prev;
          if(!objectiveDone(prev.round.laid.human, roundDef.components)) return { ...prev, message:"Complete your objective first." };
          const target = prev.round.tableMelds.find(m=>m.id===meldTarget);
          if(!target) return { ...prev, message:"Choose a target meld." };
          const cards = selectedCards(prev.round.hands.human);
          if(!canLayoffToMeld(target, cards)) return { ...prev, message:"Those cards cannot be added to that meld." };
          const next = structuredClone(prev);
          const m = next.round.tableMelds.find(x=>x.id===meldTarget);
          const applied = applyLayoffToMeld(m, cards);
          if(!applied) return { ...prev, message:"Those cards cannot be added to that meld." };
          m.cards = applied;
          next.turnAddedCardIds = [...(next.turnAddedCardIds || []), ...cards.map(c=>c.id)];
          const ids = new Set(cards.map(c=>c.id));
          next.round.hands.human = next.round.hands.human.filter(c=>!ids.has(c.id));
          next.message = `Added ${cards.length} card(s) to a meld.`;
          setSelected([]);
          return maybeFinishRound(next, "human");
        });
      }

      function discard(){
        setState(prev=>{
          if(!prev || prev.phase!=="playing" || prev.currentPlayer!=="human" || !prev.hasDrawn) return prev;
          const cards = selectedCards(prev.round.hands.human);
          if(cards.length!==1) return { ...prev, message:"Select exactly one card to discard." };
          const card = cards[0];
          const wouldGoOut = prev.round.hands.human.length === 1;
          if(wouldGoOut && !objectiveDone(prev.round.laid.human, roundDef.components)) {
            return { ...prev, message:"You can discard, but you cannot go out until your objective is complete." };
          }
          const next = structuredClone(prev);
          next.round.discard.push(card);
          next.round.hands.human = next.round.hands.human.filter(c=>c.id!==card.id);
          next.hasDrawn = false;
          next.currentPlayer = "computer";
          next.turnAddedCardIds = [];
          next.message = `You discarded ${cardLabel(card)}.`;
          setSelected([]);
          return maybeFinishRound(next, "human");
        });
      }

      function endRoundNext(){
        setState(prev=>{
          if(!prev || prev.phase !== "roundOver") return prev;
          const nextRound = prev.roundIndex + 1;
          if(nextRound >= ROUND_DEFS.length){
            return { ...prev, phase:"gameOver", message:"Game over." };
          }
          const { deck, discard, hands } = dealRound();
          return {
            ...prev,
            phase: "playing",
            roundIndex: nextRound,
            currentPlayer: prev.round.winner === "human" ? "human" : "computer",
            hasDrawn: false,
            round: { deck, discard, hands, tableMelds: [], laid:{human:[],computer:[]}, winner:null },
            turnAddedCardIds: [],
            message: `Round ${nextRound+1} started.`
          };
        });
      }

      if(!state) return <div className="p-4">Loading‚Ä¶</div>;

      return <div className="max-w-6xl mx-auto p-4 space-y-4">
        <header className="flex flex-wrap gap-2 items-center justify-between">
          <div>
            <h1 className="text-2xl font-bold">Carioca ‚Äî Human vs Computer</h1>
            <p className="text-xs text-slate-500">Version {APP_VERSION}</p>
          </div>
          <div className="flex gap-2 items-center">
            <select className="border rounded px-2 py-1" value={gameId||""} onChange={e=>switchGame(e.target.value)}>
              {games.map(g=><option key={g.id} value={g.id}>{g.name}</option>)}
            </select>
            <button className="px-3 py-1 rounded bg-slate-800 text-white" onClick={createGame}>New Game</button>
          </div>
        </header>

        <section className="grid md:grid-cols-3 gap-3">
          <div className="p-3 rounded bg-white shadow">
            <div className="font-semibold">Players</div>
            <div>{state.humanName} (You)</div>
            <div>{state.computerName} (AI: {state.aiLevel})</div>
          </div>
          <div className="p-3 rounded bg-white shadow">
            <div className="font-semibold">Round {state.roundIndex+1}: {roundDef.name}</div>
            <ul className="text-sm list-disc ml-5">
              {roundDef.components.map((c,i)=><li key={i}>{componentDesc(c)}</li>)}
            </ul>
          </div>
          <div className="p-3 rounded bg-white shadow">
            <div className="font-semibold">Score</div>
            <div>{state.humanName}: {state.totals.human}</div>
            <div>{state.computerName}: {state.totals.computer}</div>
          </div>
        </section>

        <section className="p-3 rounded bg-white shadow">
          <div className="font-semibold">Turn: {state.currentPlayer === "human" ? "You" : state.computerName}</div>
          <div className="text-sm text-slate-700">{state.message}</div>
          <div className="text-sm">Computer hand: {computerHandCount} cards</div>
          <div className="flex gap-2 mt-2">
            <button className="px-2 py-1 border rounded" disabled={state.currentPlayer!=="human" || state.hasDrawn || !state.round.deck.length} onClick={()=>draw("deck")}>Draw deck ({state.round.deck.length})</button>
            <button className="px-2 py-1 border rounded" disabled={state.currentPlayer!=="human" || state.hasDrawn || !state.round.discard.length} onClick={()=>draw("discard")}>Draw discard ({state.round.discard.length ? <span className={cardColorClass(state.round.discard[state.round.discard.length-1])}>{cardLabel(state.round.discard[state.round.discard.length-1])}</span> : "‚Äî"})</button>
            <button className="px-2 py-1 border rounded" disabled={state.currentPlayer!=="human" || !state.hasDrawn || humanObjectiveComplete} onClick={layObjective}>Lay objective meld</button>
            <select className="border rounded px-2 py-1" value={meldTarget} onChange={e=>setMeldTarget(e.target.value)}>
              <option value="">Select meld target</option>
              {state.round.tableMelds.map((m, i)=><option key={m.id} value={m.id}>{formatMeldLabel(m, i)}</option>)}
            </select>
            <button className="px-2 py-1 border rounded" disabled={state.currentPlayer!=="human" || !state.hasDrawn} onClick={addToMeld}>Add to meld</button>
            <button className="px-2 py-1 border rounded bg-slate-900 text-white" disabled={state.currentPlayer!=="human" || !state.hasDrawn} onClick={discard}>Discard</button>
          </div>
        </section>

        <section className="p-3 rounded bg-white shadow">
          <div className="mb-2 flex items-center justify-between gap-2">
            <div className="font-semibold">Your hand ({humanHand.length})</div>
            <label className="text-xs text-slate-600 flex items-center gap-2">
              Sort by
              <select className="border rounded px-2 py-1 text-sm" value={state.handSortMode || "rank"} onChange={e=>setHandSortMode(e.target.value)}>
                <option value="rank">Rank</option>
                <option value="suit">Suit</option>
              </select>
            </label>
          </div>
          <div className="flex flex-wrap gap-2">
            {sortHand(humanHand, state.handSortMode || "rank").map(c=>{
              const active = selected.includes(c.id);
              return <button key={c.id} onClick={()=>toggleSelect(c.id)} className={`px-2 py-1 rounded border ${active?"bg-blue-600 text-white":"bg-white"} ${cardColorWhenActive(c, active)}`}>{cardLabel(c)}</button>
            })}
          </div>
        </section>

        <section className="p-3 rounded bg-white shadow">
          <div className="font-semibold">Table melds</div>
          <div className="grid md:grid-cols-2 gap-2 mt-2">
            {state.round.tableMelds.map((m, i)=><div className="border rounded p-2" key={m.id}><div className="text-sm font-medium">{formatMeldLabel(m, i)}</div><div className="flex flex-wrap gap-1">{m.cards.map(c=><span key={c.id} className={`px-1.5 py-0.5 rounded ${cardColorClass(c)} ${state.turnAddedCardIds?.includes(c.id) ? "bg-amber-200 ring-1 ring-amber-400" : ""}`}>{cardLabel(c)}</span>)}</div></div>)}
            {!state.round.tableMelds.length && <div className="text-sm text-slate-600">No melds yet.</div>}
          </div>
        </section>

        {state.phase === "roundOver" && <section className="p-3 rounded bg-emerald-50 border border-emerald-300">
          <div className="font-semibold">Round complete. Winner: {state.round.winner === "human" ? state.humanName : state.computerName}</div>
          <button className="mt-2 px-3 py-1 rounded bg-emerald-700 text-white" onClick={endRoundNext}>Start next round</button>
        </section>}

        {state.phase === "gameOver" && <section className="p-3 rounded bg-indigo-50 border border-indigo-300">
          <div className="font-semibold">Game over</div>
          <div>{state.totals.human <= state.totals.computer ? `${state.humanName} wins` : `${state.computerName} wins`}</div>
        </section>}
      </div>;
    }

    function sortHand(hand, mode="rank"){
      return [...hand].sort((a,b)=>{
        if(a.joker && !b.joker) return 1;
        if(!a.joker && b.joker) return -1;
        if(a.joker && b.joker) return 0;

        if(mode === "suit") {
          const sa = SUIT_ORDER.indexOf(a.suit);
          const sb = SUIT_ORDER.indexOf(b.suit);
          if(sa !== sb) return sa - sb;
          const ra = rankNum(a.rank, true);
          const rb = rankNum(b.rank, true);
          if(ra !== rb) return ra - rb;
          return a.id.localeCompare(b.id);
        }

        const ra = rankNum(a.rank, true);
        const rb = rankNum(b.rank, true);
        if(ra !== rb) return ra - rb;
        const sa = SUIT_ORDER.indexOf(a.suit);
        const sb = SUIT_ORDER.indexOf(b.suit);
        if(sa !== sb) return sa - sb;
        return a.id.localeCompare(b.id);
      });
    }

    function findMatchingComponent(allComponents, doneComponents, cards){
      const remaining = [...allComponents];
      doneComponents.forEach(d=>{
        const i = remaining.indexOf(d);
        if(i>=0) remaining.splice(i,1);
      });
      for(const comp of remaining){ if(validateMeld(cards, comp)) return comp; }
      return null;
    }

    function maybeFinishRound(state, player){
      if(state.round.hands[player].length > 0) return state;
      const other = player === "human" ? "computer" : "human";
      const penalty = state.round.hands[other].reduce((a,c)=>a+cardPoint(c),0);
      const next = structuredClone(state);
      next.totals[other] += penalty;
      next.history.push({ round: state.roundIndex+1, winner: player, penaltyTo: other, points: penalty });
      next.phase = "roundOver";
      next.round.winner = player;
      next.message = `${player} ended round. ${other} +${penalty} points.`;
      return next;
    }

    function runAiTurn(state){
      if(!state || state.phase!=="playing" || state.currentPlayer!=="computer") return state;
      const next = structuredClone(state);
      next.turnAddedCardIds = [];
      const roundDef = ROUND_DEFS[next.roundIndex];
      const hand = next.round.hands.computer;
      const topDiscard = next.round.discard[next.round.discard.length-1];

      // draw
      const shouldTakeDiscard = topDiscard && aiWantsCard(topDiscard, hand, roundDef.components, next.round.laid.computer, next.aiLevel);
      if(shouldTakeDiscard){ hand.push(next.round.discard.pop()); }
      else if(next.round.deck.length){ hand.push(next.round.deck.pop()); }
      next.hasDrawn = true;

      // lay objective melds
      const remainingComps = [...roundDef.components];
      next.round.laid.computer.forEach(d=>{ const i=remainingComps.indexOf(d); if(i>=0) remainingComps.splice(i,1); });
      const newMelds = findObjectiveMelds(hand, remainingComps, next.aiLevel);
      if(newMelds.length){
        const used = new Set();
        for(const m of newMelds){
          m.cards.forEach(c=>used.add(c.id));
          const meldCards = m.type === "set3" ? m.cards : normalizeStraightCards(m.cards, m.type);
          next.round.tableMelds.push({ id: uid(), owner: "computer", type: m.type, cards: meldCards || m.cards });
          next.turnAddedCardIds.push(...m.cards.map(c=>c.id));
          next.round.laid.computer.push(m.type);
        }
        next.round.hands.computer = next.round.hands.computer.filter(c=>!used.has(c.id));
      }

      // layoff if objective done
      if(objectiveDone(next.round.laid.computer, roundDef.components)){
        let progressed = true;
        while(progressed){
          progressed = false;
          for(const card of [...next.round.hands.computer]){
            const target = next.round.tableMelds.find(m=>canLayoffToMeld(m,[card]));
            if(target){
              const applied = applyLayoffToMeld(target, [card]);
              if(!applied) continue;
              target.cards = applied;
              next.turnAddedCardIds.push(card.id);
              next.round.hands.computer = next.round.hands.computer.filter(c=>c.id!==card.id);
              progressed = next.aiLevel !== "Easy";
              if(next.aiLevel === "Easy") break;
            }
          }
        }
      }

      if(next.round.hands.computer.length === 0){
        return maybeFinishRound(next, "computer");
      }

      // discard
      const discardCard = chooseDiscard(next.round.hands.computer, roundDef.components, next.round.laid.computer, next.aiLevel);
      next.round.discard.push(discardCard);
      next.round.hands.computer = next.round.hands.computer.filter(c=>c.id!==discardCard.id);
      next.currentPlayer = "human";
      next.hasDrawn = false;
      next.message = `${next.computerName} took a turn and discarded ${cardLabel(discardCard)}.`;

      return maybeFinishRound(next, "computer");
    }

    function aiWantsCard(card, hand, components, done, level){
      if(level === "Easy") return Math.random() < 0.25;
      const remaining = [...components];
      done.forEach(d=>{ const i=remaining.indexOf(d); if(i>=0) remaining.splice(i,1); });
      if(!remaining.length) return false;
      if(card.joker) return true;
      const rankCount = hand.filter(c=>!c.joker && c.rank===card.rank).length;
      if(remaining.includes("set3") && rankCount>=1) return true;
      if(remaining.some(c=>c.includes("straight"))){
        const num = rankNum(card.rank);
        const near = hand.some(h=>!h.joker && Math.abs(rankNum(h.rank)-num)<=2);
        if(near) return level === "Hard" ? true : Math.random() < 0.6;
      }
      return false;
    }

    function chooseDiscard(hand, components, done, level){
      if(level === "Easy") return hand[Math.floor(Math.random()*hand.length)];
      const remaining = [...components];
      done.forEach(d=>{ const i=remaining.indexOf(d); if(i>=0) remaining.splice(i,1); });
      const scored = hand.map(c=>{
        let keep = c.joker ? 100 : 0;
        const same = hand.filter(h=>!h.joker && !c.joker && h.rank===c.rank).length;
        if(remaining.includes("set3")) keep += same*20;
        if(remaining.some(r=>r.includes("straight")) && !c.joker){
          const n = rankNum(c.rank);
          const near = hand.filter(h=>!h.joker && Math.abs(rankNum(h.rank)-n)<=2).length;
          keep += near*8;
        }
        keep -= cardPoint(c);
        return { c, keep };
      }).sort((a,b)=>a.keep-b.keep);
      return scored[0].c;
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>

  <script>
    if('serviceWorker' in navigator){
      window.addEventListener('load',()=>{navigator.serviceWorker.register('./sw.js').catch(console.error)});
    }
  </script>

</body>
</html>
